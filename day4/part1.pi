import cp.
import util.

main =>
  % R = solve(read_line()),
  go("a", R), % 0cc175b9c0f1b6a831c399e269772661
  println(R).

go(S,N) =>
  % find the lowest positive integer K such that md5(S + to_string(K)) starts with 00000...
  Vars = [A,B,C,D,E,F,G,H],
  Vars :: 0..9,
  A #> 0,

  X #= to_string(A*10**7 + B*10**6 + C*10**5 + D*10**4 + E*10**3 + F*10**2 + G*10**1 + H),
  md5(S ++ X, R),
  take(R, 5) #= "00000",
  solve([$min(N)],Vars).

md5(S,Result) =>
  % Adapted from pseudocode here: https://en.wikipedia.org/wiki/MD5#Algorithm
  % Shift table
  Shifts #= [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
            5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
            4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
            6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21],
  % Sine table
  K #= [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
      0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
      0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
      0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
      0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
      0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
      0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
      0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
      0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391],

  A0 #= 0x67452301,
  B0 #= 0xefcdab89,
  C0 #= 0x98badcfe,
  D0 #= 0x10325476,

  % pad the message
  S2 #= S ++ [chr(0x80)],
  S2_len #= S2.length(),
  S2_padding_amount #= 56 - S2_len,
  S2_range #= 1..S2_padding_amount,
  S3 #= S2 ++ [chr(0) : _ in S2_range],

  % append original message _BIT_ length in 64-bit little-endian binary
  Binary_len #= int_to_bin32(length(S)*8) ++ [chr(0) : _ in 0..3],
  S4 #= S3 ++ Binary_len,

  % process in 512-bit chunks, but we only have one
  M_chunks #= chunks_of(S4, 4),
  M #= [bin_to_int(T) : T in M_chunks],

  A #= A0,
  B #= B0,
  C #= C0,
  D #= D0,

  foreach(I in 0..63)
    % cond 1
    printf("OK 0, %w\n", C),
    F1_l #= B /\ C,
    F1_r #= ((~B) /\ D),
    F1 #= F1_l \/ F1_r,

    % cond 2
    F2 #= (D /\ B) \/ ((~D) /\ C),
    I2 #= (5*I + 1) mod 16,
    FI2 #= (F2, I2),

    % cond 3
    F3 #= B ^ C ^ D,
    I3 #= (3*I + 5) mod 16,
    FI3 #= (F3, I3),

    % cond 4
    F4 #= C ^ (B \/ (~D)),
    I4 #= (7*I) mod 16,
    FI4 #= (F4, I4),

    println("OK 1"),
    % TODO: Actually not okay -- Picat's constraint solver doesn't understand bitwise operations: /\ \/ ^
    %F1 #= ((B /\ C) \/ ((~B) /\ D),
    F #= cond(I #=< 15, F1,
              cond(I #=< 31, F2,
                cond(I #=< 47, F3, F4))),

    println("OK 2"),
    G #= cond(I #=< 15, I,
              cond(I #=< 31, I2,
                cond(I #=< 47, I3, I4))),

    println("OK 3"),
    F := (F + A + K[I+1] + M[G+1]) /\ 0xffffffff,
    A := D,
    D := C,
    C := B,
    Sw = Shifts[I+1],
    B := (B + ((F << Sw) \/ (F >> (32-Sw)))) /\ 0xffffffff,
  end,

  A1 #= (A0 + A) /\ 0xffffffff,
  B1 #= (B0 + B) /\ 0xffffffff,
  C1 #= (C0 + C) /\ 0xffffffff,
  D1 #= (D0 + D) /\ 0xffffffff,

  R #= [],
  foreach(Acc in [A1,B1,C1,D1])
    foreach(I in 0..3)
      R := R ++ (to_fstring("%02x", (Acc >> (I*8)) /\ 0xff))
    end,
  end,
  Result #= R.

bin_to_int([C1,C2,C3,C4]) = ord(C4)*(256**3) + ord(C3)*(256**2) + ord(C2)*(256**1) + ord(C1).
int_to_bin32(X) = [chr((X >> S) /\ 0xff) : S in [0,8,16,24]]
