import sat.
import util.
import bitwise.

main => go.

go => 
  % R = solve(read_line()),
  go("a", R), % 0cc175b9c0f1b6a831c399e269772661
  println(R).

go(S,N) =>
  % find the lowest positive integer K such that md5(S + to_string(K)) starts with 00000...
  Vars = [A,B,C,D,E,F,G,H],
  Vars :: 0..9,
  A #>= 1,

  % convert to list of character codes (assuming ASCII, would be better to operate directly on byte values)
  S_ord = [ord(Char) : Char in S],
  S_len = S.length(),
  S_buf = new_list(64), % not sure how much space we actually need, experiment later
  S_buf :: 0..255,

  % "copy" input array into buffer
  foreach(I in 1..S_len)
    S_buf[I] #= S_ord[I]
  end,

  % input should be followed by the character codes for the number to be minimised
  foreach(I in 1..8)
    S_buf[I + S_len] #= Vars[I] + 48
  end,
  println(s_buf=S_buf),

  % calculate actual numeric value so we can minimise it
  N #= A*10**7 + B*10**6 + C*10**5 + D*10**4 + E*10**3 + F*10**2 + G*10**1 + H,
  % printf("S: %w, S_buf: %w\n", S, S_buf),

  % describe MD5 in constraints, with S_len+8 to indicate the message size after appending a number
  % TODO: make it work first for concrete input, then reintroduce the S_buf version with constrained vars?
  % Test_list = new_list(64),
  % Test_list[1] = ord('a'),
  % % foreach(I in 2..9)
  % %   Test_list[I] = 0
  % % end,
  % % md5(Test_list, 9, R0),
  % md5(Test_list, 1, R0),
  % println(flatten([to_fstring("%02x", Byte) : Byte in R0])),
  % crash(),
  md5(S_buf, S_len + 8, R),
  % afterwards, first 5 characters of hash should be a zero char (ASCII 48)
  foreach(I in 1..1)
    R[I] #= 48
  end,

  solve([$report(printf("Vars=%w  N=%w%n", Vars, N))],Vars),
  println(r=R),
  % println(s_buf=S_buf),
  println(vars=Vars).
%solve([$min(N),ff,split,$report(printf("Vars=%w  N=%w%n", Vars, N))],Vars).

md5(S, L, R) =>
  % Adapted from pseudocode here: https://en.wikipedia.org/wiki/MD5#Algorithm
  % Shift table
  Shifts = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
             5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
             4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
             6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21],

  % Sine table
  K = [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391],

  % 32-bit accumulators
  Accumulators = [A0,B0,C0,D0],
  Accumulators :: 0..0xffffffff,
  A0 #= 0x67452301,
  B0 #= 0xefcdab89,
  C0 #= 0x98badcfe,
  D0 #= 0x10325476,

  % pad the message
  S[L+1] #= 0x80,
  Padding_amount #= 56 - L - 1,
  %println(padding_amount=Padding_amount),
  foreach(I in 1..Padding_amount)
    S[L+1+I] #= 0
  end,
  L2 #= L + 1 + Padding_amount,

  % append original message _BIT_ length in 64-bit little-endian binary
  S[L2+1] #= (L * 8) mod 256,
  S[L2+2] #= ((L * 8) / 256) mod 256,
  S[L2+3] #= ((L * 8) / 256**2) mod 256,
  S[L2+4] #= ((L * 8) / 256**3) mod 256,
  S[L2+5] #= 0,
  S[L2+6] #= 0,
  S[L2+7] #= 0,
  S[L2+8] #= 0,
  %printf("L: %w, L2: %w, S: %w\n", L, L2, S),

  % process full messages in 512-bit (64 byte) chunks, but we only have one
  % then break each 64-byte chunk into 16 4-byte chunks
  % M_chunks #= chunks_of(S, 4),
  % M #= [bin_to_int(T) : T in M_chunks],

  % Accumulator values for each of 64 iterations + initial value
  As = new_list(65),
  As :: 0..0xffffffff,
  As[1] #= A0,

  Bs = new_list(65),
  Bs :: 0..0xffffffff,
  Bs[1] #= B0,

  Cs = new_list(65),
  Cs :: 0..0xffffffff,
  Cs[1] #= C0,

  Ds = new_list(65),
  Ds :: 0..0xffffffff,
  Ds[1] #= D0,

  F1s = new_list(64),
  F1s :: 0..0xffffffff,
  F2s = new_list(64),
  F2s :: 0..0xffffffff,
  Gs = new_list(64),
  Gs :: 0..15,

  foreach(I in 0..63)
    if(I =< 15) then
      or32(and32(Bs[I+1],Cs[I+1]), and32(not32(Bs[I+1]), Ds[I+1]), F1s[I+1]),
      Gs[I+1] #= I,
    elseif(I <= 31) then
      or32(and32(Ds[I+1],Bs[I+1]), and32(not32(Ds[I+1]), Cs[I+1]), F1s[I+1]),
      Gs[I+1] #= (5*I + 1) mod 16
    elseif(I <= 47) then
      xor32(Bs[I+1], xor32(Cs[I+1],Ds[I+1]), F1s[I+1]),
      Gs[I+1] #= (3*I + 5) mod 16
    else
      % I think we need to break these up to deal with not32 confusing the domain inference
      not32(Ds[I+1], T1),
      T2 :: 0..0x100000000,
      or32(Bs[I+1], T1, T2),
      mod(T2,0x100000000,T3),
      xor32(Cs[I+1], T3, F1s[I+1]),
      Gs[I+1] #= (7*I) mod 16,
    end,
    updateF(F1s[I+1], As[I+1], K[I+1], S, Gs[I+1], F2s[I+1]),
    % println(f2b=F2s[I+1]),

    % update accumulators for next round
    % A := D,
    As[I+2] #= Ds[I+1],
    % D := C,
    Ds[I+2] #= Cs[I+1],
    % C := B,
    Cs[I+2] #= Bs[I+1],

    Sw = Shifts[I+1],
    % mod(Bs[I+1] + or32(shift_left32(F2s[I+1], Sw), shift_right32(F2s[I+1], 32-Sw)), 0x100000000, Bs[I+2]),
    or32(shift_left32(F2s[I+1], Sw), shift_right32(F2s[I+1], 32-Sw), Tmp),
    Tmp2 #= Bs[I+1] + Tmp,
    mod(Tmp2, 0x100000000, Bs[I+2]),
  end,

  Accs = [A1,B1,C1,D1],
  Accs :: 0..0x100000000,
  A1 #= (A0 + As[65]) mod 0x100000000,
  B1 #= (B0 + Bs[65]) mod 0x100000000,
  C1 #= (C0 + Cs[65]) mod 0x100000000,
  D1 #= (D0 + Ds[65]) mod 0x100000000,

  R = new_list(16),

  foreach(J in 0..3)
    foreach(I in 0..3)
      %println(ij=(I,J)),
      mod(shift_right32(Accs[J+1], I*8), 256, R[J*4 + (I+1)]),
      %println(ij_ok=(I,J)),
      % (to_fstring("%02x", (Acc >> (I*8)) /\ 0xff))
    end,
  end.

updateF(F, A, K, S, I, F2) =>
  Base #= I*4 + 1,
  T1 #= S[Base],
  T2 #= S[Base+1] * 256,
  T3 #= S[Base+2] * 256**2,
  T4 #= S[Base+3] * 256**3,
  T5 #= F + A + K + T1 + T2 + T3 + T4,
  mod(T5, 0x100000000, F2).
  
getM(S,I) = Z =>
  %println("in getM"),
  Base #= (I-1)*4 + 1,
  %println(m=S),
  Z #= S[Base] * 256**3 + S[Base + 1] * 256**2 + S[Base + 2] * 256**1 + S[Base + 3].


% bin_to_int([C1,C2,C3,C4]) = ord(C4)*(256**3) + ord(C3)*(256**2) + ord(C2)*(256**1) + ord(C1).
% int_to_bin32(X) = [chr((X >> S) /\ 0xff) : S in [0,8,16,24]]

shift_left32(A,B) = R =>
  R #= A * 2**B.

shift_right32(A,B,Z) =>
  Z #= A // 2**B.

shift_right32(A,B) = Z => shift_right32(A,B,Z).

mod(A,B,Z) =>
  Z #= A mod B.

mod(A,B) = Z => mod(A,B,Z).

not32(A,Z) =>
  Z #= (0x100000000 - (A+1)) mod 0x100000000.

not32(A) = Z => not32(A,Z).

and32(A,B,Z) =>
  Z #= (A mod 2) * (B mod 2) +
      (((A//2) mod 2) * ((B//2) mod 2) * 2) +
      (((A//4) mod 2) * ((B//4) mod 2) * 4) +
      (((A//8) mod 2) * ((B//8) mod 2) * 8) +
      (((A//16) mod 2) * ((B//16) mod 2) * 16) +
      (((A//32) mod 2) * ((B//32) mod 2) * 32) +
      (((A//64) mod 2) * ((B//64) mod 2) * 64) +
      (((A//128) mod 2) * ((B//128) mod 2) * 128) +
      (((A//256) mod 2) * ((B//256) mod 2) * 256) +
      (((A//512) mod 2) * ((B//512) mod 2) * 512) +
      (((A//1024) mod 2) * ((B//1024) mod 2) * 1024) +
      (((A//2048) mod 2) * ((B//2048) mod 2) * 2048) +
      (((A//4096) mod 2) * ((B//4096) mod 2) * 4096) +
      (((A//8192) mod 2) * ((B//8192) mod 2) * 8192) +
      (((A//16384) mod 2) * ((B//16384) mod 2) * 16384) +
      (((A//32768) mod 2) * ((B//32768) mod 2) * 32768) +
      (((A//65536) mod 2) * ((B//65536) mod 2) * 65536) +
      (((A//131072) mod 2) * ((B//131072) mod 2) * 131072) +
      (((A//262144) mod 2) * ((B//262144) mod 2) * 262144) +
      (((A//524288) mod 2) * ((B//524288) mod 2) * 524288) +
      (((A//1048576) mod 2) * ((B//1048576) mod 2) * 1048576) +
      (((A//2097152) mod 2) * ((B//2097152) mod 2) * 2097152) +
      (((A//4194304) mod 2) * ((B//4194304) mod 2) * 4194304) +
      (((A//8388608) mod 2) * ((B//8388608) mod 2) * 8388608) +
      (((A//16777216) mod 2) * ((B//16777216) mod 2) * 16777216) +
      (((A//33554432) mod 2) * ((B//33554432) mod 2) * 33554432) +
      (((A//67108864) mod 2) * ((B//67108864) mod 2) * 67108864) +
      (((A//134217728) mod 2) * ((B//134217728) mod 2) * 134217728) +
      (((A//268435456) mod 2) * ((B//268435456) mod 2) * 268435456) +
      (((A//536870912) mod 2) * ((B//536870912) mod 2) * 536870912) +
      (((A//1073741824) mod 2) * ((B//1073741824) mod 2) * 1073741824) +
      (((A//2147483648) mod 2) * ((B//2147483648) mod 2) * 2147483648).

and32(A,B) = Z => and32(A,B,Z).

or32(A,B,Z) =>
  Z #= (((A mod 2) + (B mod 2) - (A mod 2)*(B mod 2))) +
       ((((A//2) mod 2) + ((B//2) mod 2) - ((A//2) mod 2)*((B//2) mod 2)) * 2) +
       ((((A//4) mod 2) + ((B//4) mod 2) - ((A//4) mod 2)*((B//4) mod 2)) * 4) +
       ((((A//8) mod 2) + ((B//8) mod 2) - ((A//8) mod 2)*((B//8) mod 2)) * 8) +
       ((((A//16) mod 2) + ((B//16) mod 2) - ((A//16) mod 2)*((B//16) mod 2)) * 16) +
       ((((A//32) mod 2) + ((B//32) mod 2) - ((A//32) mod 2)*((B//32) mod 2)) * 32) +
       ((((A//64) mod 2) + ((B//64) mod 2) - ((A//64) mod 2)*((B//64) mod 2)) * 64) +
       ((((A//128) mod 2) + ((B//128) mod 2) - ((A//128) mod 2)*((B//128) mod 2)) * 128) +
       ((((A//256) mod 2) + ((B//256) mod 2) - ((A//256) mod 2)*((B//256) mod 2)) * 256) +
       ((((A//512) mod 2) + ((B//512) mod 2) - ((A//512) mod 2)*((B//512) mod 2)) * 512) +
       ((((A//1024) mod 2) + ((B//1024) mod 2) - ((A//1024) mod 2)*((B//1024) mod 2)) * 1024) +
       ((((A//2048) mod 2) + ((B//2048) mod 2) - ((A//2048) mod 2)*((B//2048) mod 2)) * 2048) +
       ((((A//4096) mod 2) + ((B//4096) mod 2) - ((A//4096) mod 2)*((B//4096) mod 2)) * 4096) +
       ((((A//8192) mod 2) + ((B//8192) mod 2) - ((A//8192) mod 2)*((B//8192) mod 2)) * 8192) +
       ((((A//16384) mod 2) + ((B//16384) mod 2) - ((A//16384) mod 2)*((B//16384) mod 2)) * 16384) +
       ((((A//32768) mod 2) + ((B//32768) mod 2) - ((A//32768) mod 2)*((B//32768) mod 2)) * 32768) +
       ((((A//65536) mod 2) + ((B//65536) mod 2) - ((A//65536) mod 2)*((B//65536) mod 2)) * 65536) +
       ((((A//131072) mod 2) + ((B//131072) mod 2) - ((A//131072) mod 2)*((B//131072) mod 2)) * 131072) +
       ((((A//262144) mod 2) + ((B//262144) mod 2) - ((A//262144) mod 2)*((B//262144) mod 2)) * 262144) +
       ((((A//524288) mod 2) + ((B//524288) mod 2) - ((A//524288) mod 2)*((B//524288) mod 2)) * 524288) +
       ((((A//1048576) mod 2) + ((B//1048576) mod 2) - ((A//1048576) mod 2)*((B//1048576) mod 2)) * 1048576) +
       ((((A//2097152) mod 2) + ((B//2097152) mod 2) - ((A//2097152) mod 2)*((B//2097152) mod 2)) * 2097152) +
       ((((A//4194304) mod 2) + ((B//4194304) mod 2) - ((A//4194304) mod 2)*((B//4194304) mod 2)) * 4194304) +
       ((((A//8388608) mod 2) + ((B//8388608) mod 2) - ((A//8388608) mod 2)*((B//8388608) mod 2)) * 8388608) +
       ((((A//16777216) mod 2) + ((B//16777216) mod 2) - ((A//16777216) mod 2)*((B//16777216) mod 2)) * 16777216) +
       ((((A//33554432) mod 2) + ((B//33554432) mod 2) - ((A//33554432) mod 2)*((B//33554432) mod 2)) * 33554432) +
       ((((A//67108864) mod 2) + ((B//67108864) mod 2) - ((A//67108864) mod 2)*((B//67108864) mod 2)) * 67108864) +
       ((((A//134217728) mod 2) + ((B//134217728) mod 2) - ((A//134217728) mod 2)*((B//134217728) mod 2)) * 134217728) +
       ((((A//268435456) mod 2) + ((B//268435456) mod 2) - ((A//268435456) mod 2)*((B//268435456) mod 2)) * 268435456) +
       ((((A//536870912) mod 2) + ((B//536870912) mod 2) - ((A//536870912) mod 2)*((B//536870912) mod 2)) * 536870912) +
       ((((A//1073741824) mod 2) + ((B//1073741824) mod 2) - ((A//1073741824) mod 2)*((B//1073741824) mod 2)) * 1073741824) +
       ((((A//2147483648) mod 2) + ((B//2147483648) mod 2) - ((A//2147483648) mod 2)*((B//2147483648) mod 2)) * 2147483648).

or32(A,B) = Z => or32(A,B,Z).

xor32(A,B,Z) =>
  Z #= ((A mod 2) - (B mod 2))**2 +
      (((A//2) mod 2) - ((B//2) mod 2))**2 * 2 +
      (((A//4) mod 2) - ((B//4) mod 2))**2 * 4 +
      (((A//8) mod 2) - ((B//8) mod 2))**2 * 8 +
      (((A//16) mod 2) - ((B//16) mod 2))**2 * 16 +
      (((A//32) mod 2) - ((B//32) mod 2))**2 * 32 +
      (((A//64) mod 2) - ((B//64) mod 2))**2 * 64 +
      (((A//128) mod 2) - ((B//128) mod 2))**2 * 128 +
      (((A//256) mod 2) - ((B//256) mod 2))**2 * 256 +
      (((A//512) mod 2) - ((B//512) mod 2))**2 * 512 +
      (((A//1024) mod 2) - ((B//1024) mod 2))**2 * 1024 +
      (((A//2048) mod 2) - ((B//2048) mod 2))**2 * 2048 +
      (((A//4096) mod 2) - ((B//4096) mod 2))**2 * 4096 +
      (((A//8192) mod 2) - ((B//8192) mod 2))**2 * 8192 +
      (((A//16384) mod 2) - ((B//16384) mod 2))**2 * 16384 +
      (((A//32768) mod 2) - ((B//32768) mod 2))**2 * 32768 +
      (((A//65536) mod 2) - ((B//65536) mod 2))**2 * 65536 +
      (((A//131072) mod 2) - ((B//131072) mod 2))**2 * 131072 +
      (((A//262144) mod 2) - ((B//262144) mod 2))**2 * 262144 +
      (((A//524288) mod 2) - ((B//524288) mod 2))**2 * 524288 +
      (((A//1048576) mod 2) - ((B//1048576) mod 2))**2 * 1048576 +
      (((A//2097152) mod 2) - ((B//2097152) mod 2))**2 * 2097152 +
      (((A//4194304) mod 2) - ((B//4194304) mod 2))**2 * 4194304 +
      (((A//8388608) mod 2) - ((B//8388608) mod 2))**2 * 8388608 +
      (((A//16777216) mod 2) - ((B//16777216) mod 2))**2 * 16777216 +
      (((A//33554432) mod 2) - ((B//33554432) mod 2))**2 * 33554432 +
      (((A//67108864) mod 2) - ((B//67108864) mod 2))**2 * 67108864 +
      (((A//134217728) mod 2) - ((B//134217728) mod 2))**2 * 134217728 +
      (((A//268435456) mod 2) - ((B//268435456) mod 2))**2 * 268435456 +
      (((A//536870912) mod 2) - ((B//536870912) mod 2))**2 * 536870912 +
      (((A//1073741824) mod 2) - ((B//1073741824) mod 2))**2 * 1073741824 +
      (((A//2147483648) mod 2) - ((B//2147483648) mod 2))**2 * 2147483648.

xor32(A,B) = Z => xor32(A,B,Z).
